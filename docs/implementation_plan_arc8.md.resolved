# Rev ARC8 â€” In-Process Scheduler Architecture

## Problem Statement

The current architecture runs the planner via subprocess:

```
FastAPI Process                    Scheduler Subprocess
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ cache (async)   â”‚                â”‚ cache (NEW)     â”‚ â† Different instance!
â”‚ ws_manager      â”‚   subprocess   â”‚ ws_manager      â”‚ â† Different instance!
â”‚ Socket.IO       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ (no event loop) â”‚ â† emit_sync fails!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Result:** Cache invalidation and WebSocket events fail silently.

---

## Proposed Architecture

```
FastAPI Process (Single Process)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ lifespan                                        â”‚
â”‚  â”œâ”€â”€ SchedulerService (background task)         â”‚
â”‚  â”‚    â””â”€â”€ PlannerService.run_once()             â”‚
â”‚  â”‚         â””â”€â”€ asyncio.to_thread(_run_sync)     â”‚
â”‚  â”œâ”€â”€ WebSocketManager (shared)                  â”‚
â”‚  â””â”€â”€ TTLCache (shared)                          â”‚
â”‚                                                 â”‚
â”‚ API Endpoints                                   â”‚
â”‚  â”œâ”€â”€ /api/run_planner â†’ planner_service.run()  â”‚
â”‚  â””â”€â”€ /api/scheduler/status â†’ scheduler.status  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Proposed Changes

### Phase 1: Async Planner Service

#### [NEW] [planner_service.py](file:///home/s/sync/documents/projects/darkstar/backend/services/planner_service.py)

```python
"""
Async Planner Service

Wraps the blocking PlannerPipeline in an async interface suitable
for running inside the FastAPI process without blocking the event loop.
"""
import asyncio
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any

from backend.core.cache import cache
from backend.core.websockets import ws_manager

logger = logging.getLogger("darkstar.services.planner")


@dataclass
class PlannerResult:
    success: bool
    planned_at: datetime
    slot_count: int = 0
    error: str | None = None
    duration_ms: float = 0


class PlannerService:
    """Async planner service for in-process execution."""

    async def run_once(self) -> PlannerResult:
        """
        Run the planner in a threadpool to avoid blocking the event loop.
        Handles cache invalidation and WebSocket notification automatically.
        """
        start = datetime.now()
        
        try:
            # Run blocking planner code in threadpool
            result = await asyncio.to_thread(self._run_sync)
            result.duration_ms = (datetime.now() - start).total_seconds() * 1000
            
            if result.success:
                # Invalidate cache and emit WebSocket event
                await self._notify_success(result)
            else:
                await self._notify_error(result)
            
            return result
            
        except Exception as e:
            logger.exception("Planner execution failed")
            result = PlannerResult(
                success=False,
                planned_at=start,
                error=str(e),
                duration_ms=(datetime.now() - start).total_seconds() * 1000,
            )
            await self._notify_error(result)
            return result

    def _run_sync(self) -> PlannerResult:
        """Blocking planner execution (runs in threadpool)."""
        from bin.run_planner import main as run_planner_main
        
        planned_at = datetime.now()
        
        try:
            exit_code = run_planner_main()
            
            if exit_code == 0:
                # Count slots from schedule.json
                slot_count = self._count_schedule_slots()
                return PlannerResult(
                    success=True,
                    planned_at=planned_at,
                    slot_count=slot_count,
                )
            else:
                return PlannerResult(
                    success=False,
                    planned_at=planned_at,
                    error=f"Planner exited with code {exit_code}",
                )
        except Exception as e:
            return PlannerResult(
                success=False,
                planned_at=planned_at,
                error=str(e),
            )

    def _count_schedule_slots(self) -> int:
        """Count slots in schedule.json for metadata."""
        import json
        from pathlib import Path
        
        try:
            with Path("schedule.json").open() as f:
                data = json.load(f)
                return len(data.get("schedule", []))
        except Exception:
            return 0

    async def _notify_success(self, result: PlannerResult) -> None:
        """Invalidate cache and emit WebSocket event on success."""
        try:
            await cache.invalidate("schedule:current")
            await ws_manager.emit("schedule_updated", {
                "planned_at": result.planned_at.isoformat(),
                "slot_count": result.slot_count,
                "duration_ms": result.duration_ms,
                "status": "success",
            })
            logger.info(
                "Planner completed: %d slots in %.0fms",
                result.slot_count,
                result.duration_ms,
            )
        except Exception as e:
            logger.warning(f"Failed to notify success: {e}")

    async def _notify_error(self, result: PlannerResult) -> None:
        """Emit WebSocket error event on failure."""
        try:
            await ws_manager.emit("planner_error", {
                "planned_at": result.planned_at.isoformat(),
                "error": result.error,
                "duration_ms": result.duration_ms,
            })
            logger.error("Planner failed: %s", result.error)
        except Exception as e:
            logger.warning(f"Failed to notify error: {e}")


# Global singleton
planner_service = PlannerService()
```

---

### Phase 2: Background Scheduler Service

#### [NEW] [scheduler_service.py](file:///home/s/sync/documents/projects/darkstar/backend/services/scheduler_service.py)

```python
"""
Async Scheduler Service

Background task that runs the planner on a configurable interval.
Replaces the standalone scheduler.py subprocess.
"""
import asyncio
import logging
import random
from dataclasses import dataclass
from datetime import datetime, timedelta, UTC
from pathlib import Path
from typing import Any

import yaml

from backend.services.planner_service import planner_service, PlannerResult

logger = logging.getLogger("darkstar.services.scheduler")


@dataclass
class SchedulerStatus:
    running: bool
    enabled: bool
    last_run_at: datetime | None
    next_run_at: datetime | None
    last_run_status: str | None
    last_error: str | None
    current_task: str | None  # "idle", "planning", "ml_training"


class SchedulerService:
    """Async scheduler service running as FastAPI background task."""

    def __init__(self):
        self._task: asyncio.Task | None = None
        self._running = False
        self._status = SchedulerStatus(
            running=False,
            enabled=False,
            last_run_at=None,
            next_run_at=None,
            last_run_status=None,
            last_error=None,
            current_task="idle",
        )

    @property
    def status(self) -> SchedulerStatus:
        return self._status

    async def start(self) -> None:
        """Start the scheduler background loop."""
        if self._running:
            logger.warning("Scheduler already running")
            return
        
        self._running = True
        self._status.running = True
        self._task = asyncio.create_task(self._loop(), name="scheduler_loop")
        logger.info("Scheduler started")

    async def stop(self) -> None:
        """Gracefully stop the scheduler."""
        self._running = False
        self._status.running = False
        
        if self._task:
            self._task.cancel()
            try:
                await asyncio.wait_for(self._task, timeout=5.0)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                pass
            self._task = None
        
        logger.info("Scheduler stopped")

    async def trigger_now(self) -> PlannerResult:
        """Manually trigger an immediate planner run."""
        self._status.current_task = "planning"
        try:
            result = await planner_service.run_once()
            self._update_status_from_result(result)
            return result
        finally:
            self._status.current_task = "idle"

    async def _loop(self) -> None:
        """Main scheduler loop."""
        logger.info("Scheduler loop started")
        
        # Initialize next run time
        config = self._load_config()
        self._status.enabled = config.get("enabled", False)
        
        if self._status.enabled:
            self._status.next_run_at = self._compute_next_run(
                datetime.now(UTC),
                config.get("every_minutes", 60),
                config.get("jitter_minutes", 0),
            )
        
        while self._running:
            try:
                await asyncio.sleep(30)  # Check every 30 seconds
                
                # Reload config (allows live enable/disable)
                config = self._load_config()
                self._status.enabled = config.get("enabled", False)
                
                if not self._status.enabled:
                    continue
                
                # Check if it's time to run
                now = datetime.now(UTC)
                if self._status.next_run_at and now >= self._status.next_run_at:
                    await self._run_scheduled(config)
                
            except asyncio.CancelledError:
                logger.info("Scheduler loop cancelled")
                break
            except Exception as e:
                logger.exception(f"Scheduler loop error: {e}")
                await asyncio.sleep(60)  # Back off on error

    async def _run_scheduled(self, config: dict[str, Any]) -> None:
        """Execute a scheduled planner run."""
        self._status.current_task = "planning"
        
        try:
            result = await planner_service.run_once()
            self._update_status_from_result(result)
            
            if not result.success:
                # Smart retry on failure
                await self._smart_retry(config)
            
        finally:
            self._status.current_task = "idle"
            
            # Schedule next run
            self._status.next_run_at = self._compute_next_run(
                datetime.now(UTC),
                config.get("every_minutes", 60),
                config.get("jitter_minutes", 0),
            )

    async def _smart_retry(self, config: dict[str, Any]) -> None:
        """Retry planner after failure with exponential backoff."""
        retry_delays = [60, 120, 300]  # 1min, 2min, 5min
        
        for delay in retry_delays:
            if not self._running:
                break
            
            logger.info(f"Smart retry in {delay}s...")
            await asyncio.sleep(delay)
            
            result = await planner_service.run_once()
            self._update_status_from_result(result)
            
            if result.success:
                logger.info("Smart retry succeeded")
                break

    def _update_status_from_result(self, result: PlannerResult) -> None:
        """Update scheduler status from planner result."""
        self._status.last_run_at = result.planned_at
        self._status.last_run_status = "success" if result.success else "error"
        self._status.last_error = result.error

    def _compute_next_run(
        self, from_time: datetime, every_minutes: int, jitter_minutes: int
    ) -> datetime:
        """Calculate next run time with optional jitter."""
        base = from_time + timedelta(minutes=every_minutes)
        if jitter_minutes > 0:
            jitter = random.randint(-jitter_minutes, jitter_minutes)
            base += timedelta(minutes=jitter)
        return base

    def _load_config(self) -> dict[str, Any]:
        """Load scheduler config from config.yaml."""
        try:
            with Path("config.yaml").open() as f:
                cfg = yaml.safe_load(f) or {}
            
            automation = cfg.get("automation", {})
            schedule = automation.get("schedule", {})
            
            return {
                "enabled": bool(automation.get("enable_scheduler", False)),
                "every_minutes": int(schedule.get("every_minutes", 60)),
                "jitter_minutes": int(schedule.get("jitter_minutes", 0)),
            }
        except Exception as e:
            logger.warning(f"Failed to load scheduler config: {e}")
            return {"enabled": False, "every_minutes": 60, "jitter_minutes": 0}


# Global singleton
scheduler_service = SchedulerService()
```

---

### Phase 3: API Endpoint Refactor

#### [MODIFY] [legacy.py](file:///home/s/sync/documents/projects/darkstar/backend/api/routers/legacy.py)

```diff
-import asyncio
-import contextlib
 import logging
-import sys
 from typing import Any

 from fastapi import APIRouter

+from backend.services.planner_service import planner_service

 logger = logging.getLogger("darkstar.api.legacy")
 router = APIRouter(tags=["legacy"])


 @router.post("/api/run_planner")
 async def run_planner() -> dict[str, Any]:
-    """Manually trigger the planner via subprocess (non-blocking)."""
-    try:
-        proc = await asyncio.create_subprocess_exec(...)
-        ...
-    except Exception as e:
-        return {"status": "error", "message": str(e)}
+    """Manually trigger the planner (in-process, non-blocking)."""
+    result = await planner_service.run_once()
+    
+    if result.success:
+        return {
+            "status": "ok",
+            "message": f"Planner completed: {result.slot_count} slots in {result.duration_ms:.0f}ms",
+            "slot_count": result.slot_count,
+            "duration_ms": result.duration_ms,
+        }
+    else:
+        return {
+            "status": "error",
+            "message": result.error or "Unknown error",
+        }
```

---

#### [MODIFY] [schedule.py](file:///home/s/sync/documents/projects/darkstar/backend/api/routers/schedule.py)

Add enhanced scheduler status endpoint:

```diff
+from backend.services.scheduler_service import scheduler_service

 @router.get("/api/scheduler/status")
 async def get_scheduler_status():
-    """Get scheduler status from file."""
-    try:
-        status_path = Path("data/scheduler_status.json")
-        ...
-    except Exception:
-        return {"running": False, ...}
+    """Get live scheduler status from in-process service."""
+    status = scheduler_service.status
+    return {
+        "running": status.running,
+        "enabled": status.enabled,
+        "last_run_at": status.last_run_at.isoformat() if status.last_run_at else None,
+        "next_run_at": status.next_run_at.isoformat() if status.next_run_at else None,
+        "last_run_status": status.last_run_status,
+        "last_error": status.last_error,
+        "current_task": status.current_task,
+    }
```

---

#### [MODIFY] [main.py](file:///home/s/sync/documents/projects/darkstar/backend/main.py)

Integrate scheduler with lifespan:

```diff
 @asynccontextmanager
 async def lifespan(app: FastAPI):
     """Lifespan context manager for startup/shutdown events."""
     # Startup
     logger.info("ðŸš€ Darkstar ASGI Server Starting (Rev ARC8)...")
     loop = asyncio.get_running_loop()
     ws_manager.set_loop(loop)

+    # Start background scheduler
+    from backend.services.scheduler_service import scheduler_service
+    await scheduler_service.start()

     # Deferred import: ha_socket depends on ws_manager being fully initialized
     from backend.ha_socket import start_ha_socket_client
     start_ha_socket_client()

     yield  # Server is running

     # Shutdown
     logger.info("ðŸ‘‹ Darkstar ASGI Server Shutting Down...")
+    await scheduler_service.stop()
```

---

## Verification Plan

### Automated Tests

```bash
# Run existing API tests
PYTHONPATH=. python -m pytest tests/test_api_routes.py -v

# Run performance tests (should still be fast)
PYTHONPATH=. python -m pytest tests/performance/ -v
```

### Manual Verification

1. **Start server**: `pnpm run dev`
2. **Open Dashboard** in browser with DevTools Console open
3. **Click "Run Planner"** button
4. **Observe**:
   - Console shows `ðŸ“… Schedule updated via push: {...}`
   - Chart updates automatically without refresh
   - API response includes timing and slot count

### Target Behavior

| Action | Expected Result |
|--------|-----------------|
| Click Run Planner | Chart updates in <1s |
| Change Market Strategy â†’ Run Planner | Schedule reflects new strategy |
| Browser refresh | Not required for updates |
| Server restart | Scheduler resumes automatically |
